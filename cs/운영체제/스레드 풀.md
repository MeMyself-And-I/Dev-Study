# 스레드 풀(Thread Pool)

## Thread per request model

하나의 요청마다 하나의 스레드가 요청을 처리하는 방식(요청과 스레드 1:1 맵핑)

> 만약, Thread per request 모델의 동작 방식이 요청마다 스레드를 새로 만들어서 처리하고 처리가 끝난 스레드는 버려진다면?

스레드 생성에 소요되는 시간 때문에 요청 처리가 더 오래 걸림(물론 스레드 하나 생성에 몇 초가 걸리는 것은 아니지만 스레드 생성 및 폐기는 비용이 높다)

> 요청마다 스레드를 생성하는 경우는?

처리 속도보다 더 빠르게 요청이 늘어나면
-> 스레드가 계속 생성
-> 컨텍스트 스위칭이 더 자주 발생
-> CPU 오버헤드 증가로 CPU time 낭비
-> 어느 순간 서버 전체가 응답 불가능 상태에 빠질 수 있음(메모리가 점점 고갈됨)

## Thread Pool

Thread per request model에 적용해보면,
스레드 풀은 정해진 개수만큼의 스레드를 미리 만들어 놓고 요청에 따라 스레드를 할당하여 처리 후 처리 완료한 스레드는 다시 복귀

- 미리 스레드를 여러 개 만들어 놓고 재사용(스레드 생성 시간 절약)
- 제한된 개수의 스레드를 운용(스레드 무제한 생성 방지)

1. 스레드 풀에 몇 개의 스레드를 만들어 두는게 적절한가?
   -> 이는 CPU의 코어 개수와 task(I/O bound, CPU bound)의 성향에 따라 다르다.
   -> CPU bound task라면 코어 개수만큼 혹은 그 보다 몇 개 더 많은 정도
   -> I/O bound task라면 코어 개수보다 몇 배로 해야할 지 경험적으로 찾아야함

2. 스레드 풀에서 실행될 task 개수에 제한이 없다면 스레드 풀의 큐 사이즈 제한을 확인해보아야한다.
   -> 스레드 풀 내부 큐에 요청이 무수히 많이 올 떄 큐 사이즈 제한이 없다면 큐에 요청이 계속 쌓이게 되고 결국 메모리 고갈의 위험 요인이 될 수 있다.

## Java Executors 클래스

> static 메서드로 다양한 형태의 스레드 풀을 제공

### 주의 사항

![java-executors-class](/cs/운영체제/img/java-executors-class.png)

위 클래스에서 사용하는 LinkedBlockQueue는 최대 사이즈를 Integer.MAX_VALUE(약 20억)으로 생성하여 사용하고 있다.
따라서 어플리케이션의 성격, 규모등을 따져 알맞은 클래스를 구현하거나 제공해주는 클래스를 사용하여야 한다.
(Java에서 기본적으로 제공해주는 클래스라고 안심하고 쓰다가는 큰 코 다칠 수 있다!)
